<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>{{ title or 'EasyTodo 待办' }}</title>
    <meta name="theme-color" content="#3b82f6" />
    <meta name="csrf-token" content="{{ csrf_token }}" />
    <link rel="icon" href="/static/favicon.svg" />
    <link rel="manifest" href="/static/manifest.webmanifest" />
    <link rel="stylesheet" href="/static/css/global.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" />
    <script>
      // Early apply theme to avoid flash
      (function(){
        var t = localStorage.getItem('theme');
        if(t==='dark'||t==='light') document.documentElement.setAttribute('data-theme', t);
      })();
    </script>
  </head>
  <body>
    <div class="container">
      <div class="toolbar">
        <button id="delDoneBtn" class="btn icon trash" title="清除已完成" aria-label="清除已完成"><i class="fa-solid fa-trash"></i></button>
        <button id="syncBtn" class="btn icon" title="同步" aria-label="同步"><i class="fa-solid fa-rotate"></i></button>
        <button id="themeBtn" class="btn icon" title="切换明暗" aria-label="切换明暗"><i class="fa-solid fa-circle-half-stroke"></i></button>
        <div class="spacer"></div>
        <button id="settingsBtn" class="btn icon" title="设置" aria-label="设置"><i class="fa-solid fa-gear"></i></button>
        <button id="logoutBtn" class="btn icon" title="退出登录" aria-label="退出登录"><i class="fa-solid fa-right-from-bracket"></i></button>
      </div>
      <div class="toolbar">
        <input id="newTodo" class="input" type="text" placeholder="输入待办，回车添加" />
        <button id="addBtn" class="btn primary icon" title="添加" aria-label="添加"><i class="fa-solid fa-plus"></i></button>
      </div>

      <div id="list" class="list" aria-label="待办列表"></div>

      <div class="footer">
        <span class="note" id="status"></span>
      </div>
    </div>

    <script>
      // Theme is now handled globally by /static/js/theme.js
      const $ = (sel)=>document.querySelector(sel);
      const listEl = $('#list');
      const statusEl = $('#status');
      let csrf = document.querySelector('meta[name="csrf-token"]').getAttribute('content');

      let todos = []; // local-first state
      let pendingOps = []; // queued ops while offline

      function loadPending(){
        try{ pendingOps = JSON.parse(localStorage.getItem('pendingOps')||'[]'); }
        catch{ pendingOps = [] }
      }
      function savePending(){ localStorage.setItem('pendingOps', JSON.stringify(pendingOps)); }

      function loadLocal(){
        try{ todos = JSON.parse(localStorage.getItem('todos')||'[]'); }
        catch{ todos = [] }
      }
      function saveLocal(){ localStorage.setItem('todos', JSON.stringify(todos)); }

      function render(){
        listEl.innerHTML = '';
        todos.sort((a,b)=>a.position-b.position);
        for(const t of todos){
          const row = document.createElement('div');
          row.className='item';
          row.draggable=true;
          row.dataset.id = t.id;
          row.innerHTML = `
            <input type="checkbox" class="checkbox" ${t.completed? 'checked':''} />
            <div class="text ${t.completed? 'completed':''}">${escapeHtml(t.text)}</div>
            <div class="handle" title="拖动排序">≡</div>
          `;
          const cb = row.querySelector('.checkbox');
          cb.addEventListener('change', ()=>{
            t.completed = cb.checked;
            row.querySelector('.text').classList.toggle('completed', t.completed);
            saveLocal();
            syncUpdate(t, 'status').catch(()=>{});
          });
          // Click-to-edit the text content
          const textEl = row.querySelector('.text');
          textEl.addEventListener('click', (e)=>{
            if(textEl.querySelector('input.edit-inline')) return; // already editing
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'edit-inline';
            input.value = t.text || '';
            input.setAttribute('aria-label','编辑待办');
            // prevent drag while editing
            row.draggable = false;
            const wasCompleted = textEl.classList.contains('completed');
            if(wasCompleted) textEl.classList.remove('completed');
            const finish = (commit)=>{
              const newVal = (input.value||'').trim();
              if(commit && newVal && newVal !== t.text){
                t.text = newVal;
                t.updated_at = new Date().toISOString();
                saveLocal();
                syncUpdate(t, 'text').catch(()=>{});
              }
              textEl.textContent = t.text || '';
              textEl.classList.toggle('completed', t.completed);
              row.draggable = true;
            };
            textEl.textContent = '';
            textEl.appendChild(input);
            input.focus();
            input.select();
            input.addEventListener('keydown', (ev)=>{
              if(ev.key==='Enter') { ev.preventDefault(); finish(true); }
              else if(ev.key==='Escape') { ev.preventDefault(); finish(false); }
              ev.stopPropagation();
            });
            input.addEventListener('blur', ()=> finish(true));
            e.stopPropagation();
          });
          addDnDHandlers(row);
          listEl.appendChild(row);
        }
      }

      function escapeHtml(s){
        return s.replace(/[&<>"]/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;' }[c]));
      }

      function addDnDHandlers(el){
        el.addEventListener('dragstart', (e)=>{
          el.classList.add('dragging');
          e.dataTransfer.effectAllowed='move';
        });
        el.addEventListener('dragend', ()=>{
          el.classList.remove('dragging');
          updatePositionsFromDOM();
        });
        el.addEventListener('dragover', (e)=>{
          e.preventDefault();
          const dragging = $('.item.dragging');
          if(!dragging) return;
          const rect = el.getBoundingClientRect();
          const after = (e.clientY - rect.top) > rect.height/2;
          if(after) el.after(dragging); else el.before(dragging);
        });
        // Mobile long-press helper
        let pressT;
        el.addEventListener('touchstart', ()=>{ pressT = setTimeout(()=>{ el.draggable=true; el.classList.add('dragging') }, 300) });
        el.addEventListener('touchend', ()=>{ clearTimeout(pressT); el.classList.remove('dragging') });
      }

      function updatePositionsFromDOM(){
        const ids = Array.from(document.querySelectorAll('.item')).map(n=>Number(n.dataset.id));
        ids.forEach((id, idx)=>{
          const t = todos.find(x=>x.id===id);
          if(t) t.position = idx;
        });
        saveLocal();
        syncReorder(ids).catch(()=>{});
      }

      function isOnline(){ return navigator.onLine; }

      async function api(path, opts={}){
        const init = {
          credentials: 'include',
          headers: { 'Content-Type': 'application/json' },
          ...opts
        };
        if(['POST','PUT','DELETE'].includes((init.method||'GET').toUpperCase())){
          init.headers['X-CSRF-Token'] = csrf || '';
        }
        const r = await fetch(path, init);
        if(!r.ok){
          let msg = 'HTTP '+r.status;
          try{ const body = await r.json(); if(body && body.error) msg = body.error; }catch{}
          const err = new Error(msg);
          err.status = r.status;
          throw err;
        }
        return r.json();
      }

      let unauthenticated = false;

      function setUnauthenticatedOfflineUI(){
        unauthenticated = true;
        // Hide settings/logout/sync
        const toHide = ['settingsBtn','logoutBtn','syncBtn'];
        toHide.forEach(id=>{ const el = document.getElementById(id); if(el) el.style.display='none'; });
        statusEl.textContent = '离线模式（未登录）';
      }

      async function syncFromServer(){
        try{
          const j = await api('/api/todos');
          const remote = j.todos||[];
          todos = remote;
          saveLocal();
          render();
          try{ localStorage.removeItem('loggedOut'); }catch{}
          return true;
        }catch(e){
          // If unauthorized, handle based on connectivity
          if(e && e.status === 401){
            if(isOnline()){
              location.href = '/login';
            }else{
              setUnauthenticatedOfflineUI();
            }
          }
          return false;
        }
      }
      function queueOp(op){ pendingOps.push(op); savePending(); }

      async function syncCreate(text){
        try{
          const j = await api('/api/todos', { method:'POST', body: JSON.stringify({ text }) });
          const idx = todos.findIndex(x=>!x.id && x.text===text);
          if(idx>=0) todos[idx] = j.todo; else todos.push(j.todo);
          saveLocal(); render();
        }catch(e){
          // Queue for later if offline/network error
          queueOp({ type:'create', text });
        }
      }
      async function syncUpdate(t, kind){
        if(!t.id) return;
        try{
          await api(`/api/todos/${t.id}`, { method:'PUT', body: JSON.stringify({ completed: !!t.completed, text: t.text, position: t.position }) });
        }catch(e){
          // Record intended change for conflict resolution
          queueOp({ type:'update', id: t.id, completed: !!t.completed, text: t.text, position: t.position, updated_at: t.updated_at||new Date().toISOString(), kind: kind||'update' });
        }
      }
      async function syncReorder(ids){
        try{ await api('/api/todos/reorder', { method:'POST', body: JSON.stringify({ order: ids }) }); }
        catch(e){ queueOp({ type:'reorder', order: ids.slice() }); }
      }
      async function bulkUpsert(){
        try{ await api('/api/todos/bulk_upsert', { method:'POST', body: JSON.stringify({ todos }) }); }
        catch(e){ /* ignore for now */ }
      }

      async function flushPending(){
        if(!pendingOps.length) return true;
        if(!isOnline()) return false; // wait until online
        const ops = pendingOps.slice();
        pendingOps = []; savePending();
        for(const op of ops){
          try{
            if(op.type==='create'){
              await api('/api/todos', { method:'POST', body: JSON.stringify({ text: op.text }) });
            }else if(op.type==='update'){
              // Try update; if not found and only text changed, treat as new per rule
              try{
                await api(`/api/todos/${op.id}`, { method:'PUT', body: JSON.stringify({ completed: !!op.completed, text: op.text, position: op.position }) });
              }catch(err){
                const msg = String(err||'');
                const cloudMissing = msg.includes('not_found') || msg.includes('404');
                if(cloudMissing){
                  // If local modified text, store as new; if only status changed, discard change
                  if((op.kind||'update') === 'text'){
                    await api('/api/todos', { method:'POST', body: JSON.stringify({ text: op.text }) });
                  } // else drop per priority rule
                } else {
                  throw err;
                }
              }
            }else if(op.type==='reorder'){
              await api('/api/todos/reorder', { method:'POST', body: JSON.stringify({ order: op.order }) });
            }else if(op.type==='delete_completed'){
              await api('/api/todos/completed', { method:'DELETE' });
            }
          }catch(e){
            // On any failure, put back remaining ops and stop to retry later
            pendingOps = ops.slice(ops.indexOf(op));
            savePending();
            return false;
          }
        }
        return true;
      }

      function addTodoFromInput(){
        const el = document.getElementById('newTodo');
        const text = el.value.trim();
        if(!text) return;
        const temp = { id: null, text, completed:false, position: todos.length, updated_at: new Date().toISOString() };
        todos.push(temp);
        el.value='';
        saveLocal(); render();
        syncCreate(text);
      }

      document.getElementById('addBtn').onclick = addTodoFromInput;
      document.getElementById('newTodo').addEventListener('keydown', (e)=>{ if(e.key==='Enter') addTodoFromInput(); });
      // Confirm modal for clearing completed
      const clearModal = document.createElement('div');
      clearModal.id = 'clearConfirmModal';
      clearModal.className = 'modal-backdrop';
      clearModal.setAttribute('role','dialog');
      clearModal.setAttribute('aria-modal','true');
      clearModal.setAttribute('aria-hidden','true');
      clearModal.innerHTML = `
        <div class="modal">
          <h4 class="modal-title">确认清除已完成？</h4>
          <div class="modal-actions">
            <button id="clearCancel" class="btn">取消</button>
            <button id="clearConfirm" class="btn danger">清除</button>
          </div>
        </div>`;
      document.body.appendChild(clearModal);

      function openClearModal(){ clearModal.style.display='flex'; clearModal.setAttribute('aria-hidden','false'); }
      function closeClearModal(){ clearModal.style.display='none'; clearModal.setAttribute('aria-hidden','true'); }

      document.getElementById('delDoneBtn').onclick = ()=>{ openClearModal(); };
      clearModal.addEventListener('click', (e)=>{ if(e.target===clearModal) closeClearModal(); });
      document.getElementById('clearCancel').onclick = ()=> closeClearModal();
      document.getElementById('clearConfirm').onclick = async ()=>{
        // Apply local change immediately
        todos = todos.filter(t=>!t.completed);
        todos.forEach((t,i)=>t.position=i);
        saveLocal(); render();
        closeClearModal();
        try{ await api('/api/todos/completed', { method:'DELETE' }); }
        catch(e){ queueOp({ type:'delete_completed' }); }
      };

      let lastOnlineKnown = navigator.onLine;
      // Listen to SW messages to track cache refresh time
      if (navigator.serviceWorker) {
        navigator.serviceWorker.addEventListener('message', (e)=>{
          const data = e.data || {};
          if(data && data.type === 'PAGE_CACHE_REFRESHED'){
            try{ localStorage.setItem('pageCacheUpdatedAt', String(data.at || Date.now())); }catch{}
          }
        });
      }

      document.getElementById('syncBtn').onclick = async ()=>{
        const nowOnline = isOnline();
        if(!nowOnline){
          statusEl.textContent = '已离线，请联网后重试';
          setTimeout(()=> statusEl.textContent='', 1800);
          return;
        }
        // Determine if we just transitioned from offline -> online, or cache TTL expired
        const wasOffline = !lastOnlineKnown && nowOnline;
        lastOnlineKnown = nowOnline;
        let shouldRefreshCache = wasOffline;
        try{
          const ttlMs = 24*60*60*1000; // 24 hours
          const last = parseInt(localStorage.getItem('pageCacheUpdatedAt')||'0', 10) || 0;
          if(!last || (Date.now()-last) > ttlMs){ shouldRefreshCache = true; }
        }catch{}
        if(shouldRefreshCache && navigator.serviceWorker && navigator.serviceWorker.controller){
          try{ navigator.serviceWorker.controller.postMessage({ type:'REFRESH_PAGE_CACHE' }); }catch{}
        }
        statusEl.textContent = '同步中…';
        // First flush pending local changes, then pull from server
        const flushed = await flushPending();
        const ok = await syncFromServer();
        statusEl.textContent = (flushed && ok) ? '已同步' : '同步失败（网络异常或未登录）';
        setTimeout(()=> statusEl.textContent='', 1200);
      };
      document.getElementById('settingsBtn').onclick = ()=>{ location.href = '/settings' };
      document.getElementById('logoutBtn').onclick = async ()=>{
        try{ await fetch('/api/auth/logout', { method:'POST', credentials:'include' }); }catch{}
        // Clear all local storage (app data and prefs) on logout
        // Keep an explicit flag so that offline logout is respected when back online
        try{ localStorage.clear(); localStorage.setItem('loggedOut','1'); }catch{}
        // Ask SW to purge caches but keep offline page available
        if(navigator.serviceWorker && navigator.serviceWorker.controller){
          try{ navigator.serviceWorker.controller.postMessage({ type:'LOGOUT_CLEAR_CACHES_KEEP_OFFLINE' }); }catch{}
          // Also clear page cache for older SW versions
          try{ navigator.serviceWorker.controller.postMessage({ type:'CLEAR_PAGE_CACHE' }); }catch{}
        }
        location.href = '/login';
      };

      (async function init(){
        loadLocal();
        loadPending();
        render();
        // If we have an explicit loggedOut flag, handle both online/offline consistently
        try{
          const flaggedLogout = localStorage.getItem('loggedOut') === '1';
          if(flaggedLogout){
            if(isOnline()){
              try{ await fetch('/api/auth/logout', { method:'POST', credentials:'include' }); }catch{}
              location.href = '/login';
              return;
            }else{
              setUnauthenticatedOfflineUI();
            }
          }
        }catch{}

        // If online, try to flush and then fetch
        if(isOnline()){
          await flushPending();
          await syncFromServer();
        }
        // If offline and we have an explicit loggedOut flag, show unauth offline UI
        try{
          if(!isOnline() && localStorage.getItem('loggedOut') === '1'){
            setUnauthenticatedOfflineUI();
          }
        }catch{}
        // Listen network changes to hint user
        window.addEventListener('online', async ()=>{
          try{
            if(localStorage.getItem('loggedOut') === '1'){
              // Ensure server session is invalidated when back online, then go to login
              try{ await fetch('/api/auth/logout', { method:'POST', credentials:'include' }); }catch{}
              location.href = '/login';
              return;
            }
          }catch{}
          statusEl.textContent = '网络已连接，正在同步…';
          const flushed = await flushPending();
          const ok = await syncFromServer();
          statusEl.textContent = (flushed && ok) ? '已同步' : '同步失败（网络异常或未登录）';
          setTimeout(()=> statusEl.textContent='', 1200);
        });
        window.addEventListener('offline', ()=>{
          statusEl.textContent = unauthenticated ? '离线模式（未登录）' : '已离线';
          setTimeout(()=> statusEl.textContent='', 1200);
        });
      })();
  </script>
    <style>
      /* Inline editor for todo text */
      .edit-inline{
        width:100%;
        border:1px solid var(--border);
        border-radius:6px;
        padding:6px 8px;
        background:var(--panel);
        color:var(--fg);
        font: inherit;
      }
      .edit-inline:focus{ outline:none; border-color:var(--accent); box-shadow:0 0 0 3px color-mix(in oklab, var(--accent) 20%, transparent); }
    </style>
    <script src="/static/js/theme.js"></script>
    <script src="/static/js/pwa.js"></script>
    <footer class="site-footer">
      Powered by <a href="https://github.com/essesoul/EasyTodo" target="_blank" rel="noopener noreferrer">EasyTodo</a> · Copyright <a href="https://github.com/essesoul" target="_blank" rel="noopener noreferrer">Essesoul</a>
    </footer>
  </body>
  </html>
